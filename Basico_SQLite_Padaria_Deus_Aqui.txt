
Guia Completo: CRUD com SQLite3 em Python

1. Introdu√ß√£o
O SQLite √© um sistema de banco de dados SQL leve e auto-suficiente, que utiliza um √∫nico arquivo para armazenar todos os dados. Ele √© considerado ideal para aplica√ß√µes de pequeno e m√©dio porte, pois dispensa a necessidade de um servidor dedicado. Em Python, a biblioteca nativa sqlite3 permite que voc√™ interaja com bancos SQLite de forma simples e direta.
Porque usar SQLite3?
- Leve e port√°til: Basta um arquivo (.db) para armazenar e transportar os dados.
- Sem configura√ß√£o complexa: Vem integrado com o Python, sem necessidade de instaladores adicionais.
- F√°cil de operar: Ideal para prot√≥tipos, MVPs, aplicativos desktop e sistemas embarcados.
- Ideal para CRUD: Opera√ß√µes simples de Create, Read, Update e Delete podem ser implementadas rapidamente.

2. Configura√ß√£o e Primeiros Passos com SQLite3
2.1 Importando a Biblioteca
import sqlite3


- O que faz?
Importa a biblioteca sqlite3 para que possamos utilizar suas fun√ß√µes e m√©todos para interagir com o SQLite dentro do Python.
- Por que √© essencial?
Sem essa importa√ß√£o, voc√™ n√£o ter√° acesso aos m√©todos que permitem:
- Conectar/ criar um banco de dados.
- Executar comandos SQL.
- Manipular os resultados de consultas.
2.2 Estabelecendo a Conex√£o com o Banco de Dados
conexao = sqlite3.connect("padaria.db")


- O que faz?
Cria uma conex√£o com o banco de dados chamado "padaria.db". Se esse arquivo n√£o existir, ele ser√° criado automaticamente.
- Boas pr√°ticas:
- Utilize nomes que identifiquem o projeto (ex.: "padaria.db") para facilitar a organiza√ß√£o dos dados.
- Em projetos maiores, √© comum isolar a l√≥gica de conex√£o em uma fun√ß√£o ou classe.
2.3 Criando um Cursor para Executar Comandos SQL
cursor = conexao.cursor()


- O que faz?
O cursor √© um objeto que permite a execu√ß√£o de comandos SQL (como SELECT, INSERT, UPDATE e DELETE) e a itera√ß√£o sobre os resultados.
- Import√¢ncia:
Sem o cursor, voc√™ n√£o ter√° acesso ao m√©todo de execu√ß√£o dos comandos e n√£o conseguir√° manipular os dados.
2.4 Executando Consultas e Obtendo Resultados
A. Executando uma Consulta
Antes de usar os m√©todos de busca (como fetchall() ou fetchone()), voc√™ deve executar uma consulta:
cursor.execute("SELECT * FROM produtos")


- Explica√ß√£o:
Este comando executa uma consulta SQL que seleciona todos os registros da tabela produtos.
B. Obtendo os Resultados com fetchall()
resultado = cursor.fetchall()


- O que faz?
Este m√©todo retorna uma lista com todos os registros resultantes da consulta SQL executada anteriormente.
- Observa√ß√£o:
O m√©todo fetchall() s√≥ faz sentido depois de uma chamada a execute(). Sem a execu√ß√£o de uma consulta, ele n√£o retornar√° nenhum dado.
2.5 Fechando a Conex√£o
conexao.close()


- O que faz?
Fecha a conex√£o com o banco de dados, liberando recursos e garantindo que as opera√ß√µes realizadas sejam finalizadas de forma segura.
- Boa pr√°tica:
Sempre feche a conex√£o assim que terminar suas opera√ß√µes para evitar vazamentos de mem√≥ria e problemas de bloqueio do banco de dados.

3. Opera√ß√µes B√°sicas (CRUD) com SQLite3
As opera√ß√µes CRUD s√£o os pilares para manipula√ß√£o dos dados. Cada uma delas √© realizada utilizando comandos SQL atrav√©s do sqlite3.
3.1 Create (Inserir Dados)
Exemplo: Inserir um novo produto
cursor.execute(
    "INSERT INTO produtos (nome, preco, validade) VALUES (?, ?, ?)",
    ("P√£o Franc√™s", 0.50, "2025-12-30")
)
conexao.commit()  # Confirma a transa√ß√£o e salva as mudan√ßas no banco


- Detalhes:
- Utilizamos par√¢metros (?) para evitar problemas de inje√ß√£o de SQL.
- O comando commit() √© essencial para aplicar as mudan√ßas.
3.2 Read (Consultar Dados)
Exemplo: Selecionar todos os registros da tabela
cursor.execute("SELECT * FROM produtos")
produtos = cursor.fetchall()

for produto in produtos:
    print(produto)


- Detalhes:
- fetchall() retorna uma lista de tuplas, onde cada tupla representa um registro.
- √â poss√≠vel filtrar dados utilizando cl√°usulas WHERE, ORDER BY, entre outras.
3.3 Update (Atualizar Dados)
Exemplo: Atualizar o pre√ßo de um produto
cursor.execute(
    "UPDATE produtos SET preco = ? WHERE nome = ?",
    (0.55, "P√£o Franc√™s")
)
conexao.commit()


- Detalhes:
- A cl√°usula WHERE garante que somente os registros desejados sejam atualizados.
- Sempre confirme a altera√ß√£o com commit().
3.4 Delete (Excluir Dados)
Exemplo: Remover um produto
cursor.execute("DELETE FROM produtos WHERE nome = ?", ("P√£o Franc√™s",))
conexao.commit()


- Detalhes:
- Assim como o update, a cl√°usula WHERE √© essencial para evitar a exclus√£o de todos os registros.
- Confirme sempre com commit().

4. Boas Pr√°ticas ao Trabalhar com SQLite3
4.1 Uso de Par√¢metros nas Consultas
- Sempre utilize par√¢metros (como ?) em comandos SQL para evitar inje√ß√£o de SQL.
- Exemplo:
cursor.execute("SELECT * FROM produtos WHERE preco < ?", (5.00,))


4.2 Gerenciamento de Conex√£o
- Sempre feche a conex√£o ap√≥s concluir as opera√ß√µes para liberar recursos:
conexao.close()
- Use o padr√£o "context manager" com a cl√°usula with para gerenciar automaticamente a abertura e o fechamento:
import sqlite3
with sqlite3.connect("padaria.db") as conexao:
    cursor = conexao.cursor()
    # opera√ß√µes SQL aqui
# A conex√£o ser√° fechada automaticamente ao sair do bloco


4.3 Controle de Transa√ß√µes
- Utilize conexao.commit() ap√≥s cada opera√ß√£o que altera o banco (INSERT, UPDATE, DELETE).
- Em casos de falha, usar conexao.rollback() pode ajudar a manter a integridade dos dados.
4.4 Estrutura Modular
- Separe a l√≥gica de conex√£o, execu√ß√£o de comandos e fechamento em fun√ß√µes ou classes, facilitando a manuten√ß√£o e expans√£o do c√≥digo.
4.5 Tratamento de Erros
- Use blocos try...except para capturar exce√ß√µes e tratar erros adequadamente:
try:
    conexao = sqlite3.connect("padaria.db")
    cursor = conexao.cursor()
    # Executar comandos
    conexao.commit()
except sqlite3.Error as e:
    print("Erro ao operar no banco:", e)
    conexao.rollback()
finally:
    if conexao:
        conexao.close()



5. Exemplo Completo de um CRUD
Abaixo, um exemplo que une todas as opera√ß√µes CRUD com boas pr√°ticas:
import sqlite3

def criar_conexao(db_file):
    try:
        conexao = sqlite3.connect(db_file)
        return conexao
    except sqlite3.Error as e:
        print(e)
    return None

def criar_tabela(conexao):
    try:
        cursor = conexao.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS produtos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nome TEXT NOT NULL,
                preco REAL NOT NULL,
                validade TEXT
            )
        """)
        conexao.commit()
    except sqlite3.Error as e:
        print("Erro ao criar tabela:", e)

def inserir_produto(conexao, produto):
    try:
        cursor = conexao.cursor()
        cursor.execute(
            "INSERT INTO produtos (nome, preco, validade) VALUES (?, ?, ?)",
            produto
        )
        conexao.commit()
        return cursor.lastrowid
    except sqlite3.Error as e:
        print("Erro ao inserir produto:", e)
        conexao.rollback()
        return None

def consultar_produtos(conexao):
    cursor = conexao.cursor()
    cursor.execute("SELECT * FROM produtos")
    return cursor.fetchall()

def atualizar_produto(conexao, novo_preco, nome_produto):
    try:
        cursor = conexao.cursor()
        cursor.execute("UPDATE produtos SET preco = ? WHERE nome = ?", (novo_preco, nome_produto))
        conexao.commit()
    except sqlite3.Error as e:
        print("Erro ao atualizar produto:", e)
        conexao.rollback()

def remover_produto(conexao, nome_produto):
    try:
        cursor = conexao.cursor()
        cursor.execute("DELETE FROM produtos WHERE nome = ?", (nome_produto,))
        conexao.commit()
    except sqlite3.Error as e:
        print("Erro ao remover produto:", e)
        conexao.rollback()

# Uso do CRUD
if __name__ == "__main__":
    db = "padaria.db"
    conexao = criar_conexao(db)
    if conexao is not None:
        criar_tabela(conexao)
        
        # Create
        produto = ("P√£o Franc√™s", 0.50, "2025-12-30")
        inserir_produto(conexao, produto)
        
        # Read
        produtos = consultar_produtos(conexao)
        print("Produtos no estoque:")
        for prod in produtos:
            print(prod)
        
        # Update
        atualizar_produto(conexao, 0.55, "P√£o Franc√™s")
        
        # Read novamente para confirmar altera√ß√£o
        produtos = consultar_produtos(conexao)
        print("Produtos ap√≥s atualiza√ß√£o:")
        for prod in produtos:
            print(prod)
        
        # Delete
        remover_produto(conexao, "P√£o Franc√™s")
        
        # Final consulta
        produtos = consultar_produtos(conexao)
        print("Produtos ap√≥s remo√ß√£o:")
        for prod in produtos:
            print(prod)
        
        conexao.close()
    else:
        print("Erro! N√£o foi poss√≠vel criar a conex√£o com o banco de dados.")

Ó∑õÓ∑úÓ∑ôÓ∑ö

6. Conclus√£o
Principais pontos a serem lembrados:
- import sqlite3: √â indispens√°vel para acessar as fun√ß√µes do SQLite3 em Python.
- conexao = sqlite3.connect("padaria.db"): Garante a cria√ß√£o ou conex√£o com o banco de dados.
- cursor = conexao.cursor(): Permite executar comandos SQL.
- cursor.fetchall(): Retorna os resultados de uma consulta SQL (sempre ap√≥s um execute()).
- conexao.close(): Fecha a conex√£o, preservando os recursos do sistema.
Adotando as boas pr√°ticas apresentadas, voc√™ estar√° preparado para transformar seus dados estruturados (como seu estoque da padaria) em um sistema robusto e escal√°vel. Com essa base s√≥lida, a integra√ß√£o com frameworks (como Flask) e outras tecnologias (como SQLite em produ√ß√£o) se torna natural e segura.



√ìtima solicita√ß√£o! Vamos analisar detalhadamente os comandos em ingl√™s presentes nas opera√ß√µes CRUD do SQLite3, explicando o significado de cada palavra e por que algumas est√£o em mai√∫sculas. Tamb√©m explicarei o conceito dos pontos de interroga√ß√£o (?) nas consultas SQL. üöÄ


1Ô∏è‚É£ Comandos SQL em Ingl√™s e por que est√£o em Mai√∫sculas
CREATE TABLE
CREATE TABLE produtos (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nome TEXT NOT NULL,
    preco REAL NOT NULL,
    validade TEXT
)


‚úÖ Palavras em ingl√™s e seus significados:
- CREATE ‚Üí "Criar" ‚Üí Define uma nova tabela no banco de dados.
- TABLE ‚Üí "Tabela" ‚Üí Especifica que um objeto do banco de dados a ser criado √© uma tabela.
- PRIMARY KEY ‚Üí "Chave Prim√°ria" ‚Üí Identifica um registro de forma √∫nica.
- AUTOINCREMENT ‚Üí "Autoincrementar" ‚Üí Faz com que o valor da chave prim√°ria aumente automaticamente.
- TEXT ‚Üí "Texto" ‚Üí Tipo de dado que armazena caracteres.
- REAL ‚Üí "Real" ‚Üí Tipo de dado para n√∫meros com casas decimais.
- NOT NULL ‚Üí "N√£o pode ser nulo" ‚Üí Garante que o campo deve ter um valor e n√£o pode ficar vazio.
üìå Por que essas palavras est√£o em MAI√öSCULAS?
No SQL, comandos como CREATE TABLE e PRIMARY KEY s√£o palavras reservadas, o que significa que fazem parte da sintaxe do SQL.
üëâ Usar mai√∫sculas √© uma conven√ß√£o para diferenciar comandos SQL dos nomes das tabelas e colunas, melhorando a legibilidade do c√≥digo.

INSERT INTO
INSERT INTO produtos (nome, preco, validade) VALUES (?, ?, ?)


‚úÖ Palavras em ingl√™s e seus significados:
- INSERT INTO ‚Üí "Inserir dentro de" ‚Üí Adiciona um novo registro a uma tabela.
- VALUES ‚Üí "Valores" ‚Üí Define os valores que ser√£o inseridos nas colunas especificadas.
üìå Mai√∫sculas:
INSERT INTO √© um comando SQL, ent√£o fica em mai√∫sculas por conven√ß√£o, para deixar claro que √© um comando e n√£o um nome de tabela ou coluna.

SELECT
SELECT * FROM produtos


‚úÖ Palavras em ingl√™s e seus significados:
- SELECT ‚Üí "Selecionar" ‚Üí Retorna dados armazenados no banco de dados.
- FROM ‚Üí "De" ‚Üí Especifica a tabela de onde os dados ser√£o extra√≠dos.
- (*) ‚Üí "Tudo" ‚Üí O asterisco representa todos os campos de um registro, ou seja, solicita que sejam retornadas todas as colunas da tabela.
üìå Mai√∫sculas:
Assim como CREATE e INSERT, o SELECT √© um comando SQL essencial, ent√£o est√° em mai√∫sculas para facilitar a leitura do c√≥digo.

UPDATE
UPDATE produtos SET preco = ? WHERE nome = ?


‚úÖ Palavras em ingl√™s e seus significados:
- UPDATE ‚Üí "Atualizar" ‚Üí Modifica os dados de um registro existente.
- SET ‚Üí "Definir" ‚Üí Informa qual campo ser√° alterado.
- WHERE ‚Üí "Onde" ‚Üí Especifica qual registro ser√° atualizado (para evitar alterar todos os registros da tabela).
üìå Mai√∫sculas:
UPDATE, SET e WHERE s√£o comandos SQL, ent√£o seguem a conven√ß√£o de serem escritos em mai√∫sculas.

DELETE
DELETE FROM produtos WHERE nome = ?


‚úÖ Palavras em ingl√™s e seus significados:
- DELETE ‚Üí "Excluir" ‚Üí Remove um ou mais registros da tabela.
- FROM ‚Üí "De" ‚Üí Especifica de qual tabela os registros ser√£o removidos.
- WHERE ‚Üí "Onde" ‚Üí Define qual registro espec√≠fico ser√° deletado.
üìå Mai√∫sculas:
DELETE, FROM e WHERE s√£o comandos SQL, ent√£o seguem a conven√ß√£o de legibilidade e destaque.

2Ô∏è‚É£ O conceito dos pontos de interroga√ß√£o (?)
Nos comandos SQL, os pontos de interroga√ß√£o (?) s√£o utilizados para substituir valores dinamicamente dentro da consulta.
Por que usar ? ao inv√©s de valores fixos?
‚úÖ Evita inje√ß√£o de SQL
Os ? atuam como placeholders, protegendo o banco contra ataques de SQL Injection, onde hackers podem inserir comandos maliciosos.
‚úÖ Facilita a substitui√ß√£o de valores
Ao inv√©s de definir valores fixos diretamente no SQL (INSERT INTO produtos VALUES ('P√£o', 2.50, '2025-12-30')), podemos inserir os valores via Python, tornando o c√≥digo mais flex√≠vel e seguro:
cursor.execute("INSERT INTO produtos (nome, preco, validade) VALUES (?, ?, ?)", ("P√£o Franc√™s", 0.50, "2025-12-30"))

Ó∑ôÓ∑ö
- Os valores "P√£o Franc√™s", 0.50 e "2025-12-30" substituir√£o os ? automaticamente.
- Isso previne problemas de seguran√ßa e permite que o mesmo comando seja reutilizado para v√°rios produtos.
Aplica√ß√£o dos ? nos comandos CRUD
‚úÖ INSER√á√ÉO de dados
cursor.execute("INSERT INTO produtos (nome, preco, validade) VALUES (?, ?, ?)", ("P√£o Franc√™s", 0.50, "2025-12-30"))

Ó∑ôÓ∑ö
Os valores fornecidos em uma tupla substituem os ?, tornando a inser√ß√£o din√¢mica e segura.
‚úÖ ATUALIZA√á√ÉO de dados
cursor.execute("UPDATE produtos SET preco = ? WHERE nome = ?", (0.55, "P√£o Franc√™s"))

Ó∑ôÓ∑ö
O ? √© substitu√≠do pelos valores 0.55 (pre√ßo atualizado) e "P√£o Franc√™s" (produto que ser√° modificado).
‚úÖ EXCLUS√ÉO de dados
cursor.execute("DELETE FROM produtos WHERE nome = ?", ("P√£o Franc√™s",))


O ? √© substitu√≠do pelo nome do produto que ser√° removido.
‚úÖ CONSULTA de dados com filtro
cursor.execute("SELECT * FROM produtos WHERE preco < ?", (5.00,))


Aqui, o ? √© substitu√≠do pelo pre√ßo m√°ximo de 5.00, retornando produtos mais baratos que esse valor.
üìå Conclus√£o:
Os pontos de interroga√ß√£o (?) tornam os comandos mais seguros, reutiliz√°veis e din√¢micos, permitindo que os valores sejam passados a partir de vari√°veis no Python. Isso √© fundamental para um c√≥digo mais profissional e protegido contra ataques.

Resumo Final
üìù Palavras em ingl√™s:
Cada palavra nos comandos SQL tem um significado claro, e os termos est√£o em mai√∫sculas para seguir a conven√ß√£o de legibilidade e diferencia√ß√£o.
üîç Mai√∫sculas:
- Comandos SQL como CREATE, SELECT, INSERT, UPDATE, DELETE sempre ficam em mai√∫sculas para melhorar a clareza do c√≥digo.
- Nomes de tabelas e colunas n√£o precisam estar em mai√∫sculas, pois s√£o identificadores criados pelo usu√°rio.
‚ùì Uso de ? nos comandos CRUD:
Os ? atuam como placeholders que garantem seguran√ßa, flexibilidade e prote√ß√£o contra ataques de SQL Injection.
üöÄ Conclus√£o Final:
Dominar esses conceitos √© essencial para escrever c√≥digo SQL eficiente e para um banco de dados seguro no seu projeto! Se quiser que eu aprofunde ainda mais alguma parte, me avise! üî•üí°

Linha 1: Importando a Biblioteca
import sqlite3


- Descri√ß√£o:
Importa a biblioteca nativa do Python para interagir com bancos de dados SQLite.
- Por qu√™:
Sem essa importa√ß√£o, n√£o ter√≠amos acesso √†s fun√ß√µes e classes necess√°rias para criar conex√µes, executar comandos SQL e gerenciar a persist√™ncia dos dados.

Fun√ß√£o: criar_conexao(db_file)
def criar_conexao(db_file):


- Descri√ß√£o:
Define uma fun√ß√£o chamada criar_conexao que recebe o nome do arquivo do banco de dados (db_file) como par√¢metro.
- Prop√≥sito:
Criar e retornar uma conex√£o com o banco de dados especificado.
    try:


- Descri√ß√£o:
Inicia um bloco try para capturar exce√ß√µes que possam ocorrer durante o processo de conex√£o com o banco.
        conexao = sqlite3.connect(db_file)


- Descri√ß√£o:
Tenta conectar ao banco de dados cujo nome foi passado em db_file.
- Comportamento:
Se o arquivo n√£o existir, o SQLite criar√° um novo arquivo chamado "padaria.db" (ou outro nome fornecido).
        return conexao


- Descri√ß√£o:
Se a conex√£o for bem-sucedida, retorna o objeto de conex√£o para ser usado em outras opera√ß√µes.
    except sqlite3.Error as e:
        print(e)


- Descri√ß√£o:
Se ocorrer algum erro (do tipo sqlite3.Error), o bloco except captura o erro e imprime a mensagem de erro (e).
    return None


- Descri√ß√£o:
Caso o bloco try falhe (ou mesmo ap√≥s o bloco except), a fun√ß√£o retorna None, sinalizando que a conex√£o n√£o foi estabelecida.

Fun√ß√£o: criar_tabela(conexao)
def criar_tabela(conexao):


- Descri√ß√£o:
Define uma fun√ß√£o chamada criar_tabela que recebe como par√¢metro a conex√£o aberta com o banco de dados.
    try:


- Descri√ß√£o:
Inicia um bloco de tentativa para criar a tabela, capturando quaisquer erros que possam ocorrer.
        cursor = conexao.cursor()


- Descri√ß√£o:
Cria um cursor a partir da conex√£o.
- Prop√≥sito do Cursor:
Permite executar comandos SQL e manipular os resultados.
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS produtos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nome TEXT NOT NULL,
                preco REAL NOT NULL,
                validade TEXT
            )
        """)


- Descri√ß√£o:
Executa um comando SQL que cria uma tabela chamada produtos se ela ainda n√£o existir.
- Detalhamento do Comando SQL:
- id INTEGER PRIMARY KEY AUTOINCREMENT: Cria uma coluna id que √© chave prim√°ria e incrementa automaticamente.
- nome TEXT NOT NULL: Cria uma coluna nome do tipo texto, que n√£o pode ser nula.
- preco REAL NOT NULL: Cria uma coluna preco para valores reais (n√∫meros flutuantes) e obriga que haja um valor.
- validade TEXT: Cria uma coluna validade para armazenar a data de validade como texto (poderia ser usado um tipo de data, mas aqui optou-se por texto).
        conexao.commit()


- Descri√ß√£o:
Confirma (faz o "commit") da transa√ß√£o, garantindo que a cria√ß√£o da tabela seja salva no banco de dados.
    except sqlite3.Error as e:
        print("Erro ao criar tabela:", e)


- Descri√ß√£o:
Se houver qualquer erro ao executar o comando SQL ou durante a opera√ß√£o, o erro √© capturado e uma mensagem de erro √© exibida.

Fun√ß√£o: inserir_produto(conexao, produto)
def inserir_produto(conexao, produto):


- Descri√ß√£o:
Define uma fun√ß√£o que insere um novo registro na tabela produtos.
- Par√¢metros:
- conexao: objeto de conex√£o com o banco.
- produto: uma tupla contendo os valores (nome, preco, validade) do produto.
    try:


- Descri√ß√£o:
Inicia um bloco try para tentar executar a inser√ß√£o.
        cursor = conexao.cursor()


- Descri√ß√£o:
Cria um cursor para executar o comando SQL.
        cursor.execute(
            "INSERT INTO produtos (nome, preco, validade) VALUES (?, ?, ?)",
            produto
        )


- Descri√ß√£o:
Executa um comando SQL para inserir um novo produto.
- Detalhamento:
- O comando usa placeholders (?) para os valores, que ser√£o substitu√≠dos pelo conte√∫do da tupla produto.
- Essa abordagem √© recomendada para evitar inje√ß√£o de SQL.
        conexao.commit()


- Descri√ß√£o:
Confirma a inser√ß√£o dos dados no banco, salvando a transa√ß√£o.
        return cursor.lastrowid


- Descri√ß√£o:
Retorna o ID (gerado automaticamente) do √∫ltimo registro inserido, o que pode ser √∫til para refer√™ncia.
    except sqlite3.Error as e:
        print("Erro ao inserir produto:", e)
        conexao.rollback()
        return None


- Descri√ß√£o:
Caso ocorra um erro:
- Imprime uma mensagem de erro.
- Executa rollback para desfazer qualquer altera√ß√£o parcial na transa√ß√£o.
- Retorna None, indicando que a inser√ß√£o falhou.

Fun√ß√£o: consultar_produtos(conexao)
def consultar_produtos(conexao):


- Descri√ß√£o:
Define uma fun√ß√£o para consultar e retornar todos os registros da tabela produtos.
    cursor = conexao.cursor()


- Descri√ß√£o:
Cria um cursor para executar comandos SQL.
    cursor.execute("SELECT * FROM produtos")


- Descri√ß√£o:
Executa um comando SQL que seleciona todos os registros da tabela produtos.
    return cursor.fetchall()


- Descri√ß√£o:
Retorna todos os resultados da consulta em forma de lista de tuplas, onde cada tupla representa um registro.

Fun√ß√£o: atualizar_produto(conexao, novo_preco, nome_produto)
def atualizar_produto(conexao, novo_preco, nome_produto):


- Descri√ß√£o:
Define uma fun√ß√£o para atualizar o pre√ßo (preco) de um produto espec√≠fico identificado pelo nome_produto.
    try:


- Descri√ß√£o:
Inicia um bloco try para capturar poss√≠veis erros durante a atualiza√ß√£o.
        cursor = conexao.cursor()


- Descri√ß√£o:
Cria um cursor para executar o comando SQL.
        cursor.execute("UPDATE produtos SET preco = ? WHERE nome = ?", (novo_preco, nome_produto))

Ó∑ôÓ∑ö
- Descri√ß√£o:
Executa o comando SQL para atualizar o pre√ßo:
- SET preco = ?: Define que o novo pre√ßo ser√° igual ao valor passado em novo_preco.
- WHERE nome = ?: Indica que a altera√ß√£o deve ocorrer apenas para o registro cujo nome corresponda a nome_produto.
- Os valores s√£o passados como uma tupla (novo_preco, nome_produto).
        conexao.commit()


- Descri√ß√£o:
Confirma a atualiza√ß√£o no banco de dados, salvando as altera√ß√µes.
    except sqlite3.Error as e:
        print("Erro ao atualizar produto:", e)
        conexao.rollback()


- Descri√ß√£o:
Caso haja algum erro na atualiza√ß√£o:
- O erro √© impresso.
- A opera√ß√£o √© revertida (rollback) para manter a integridade dos dados.

Fun√ß√£o: remover_produto(conexao, nome_produto)
def remover_produto(conexao, nome_produto):


- Descri√ß√£o:
Define uma fun√ß√£o que remove um registro da tabela produtos com base no nome do produto.
    try:


- Descri√ß√£o:
Inicia um bloco try para tentar executar a exclus√£o.
        cursor = conexao.cursor()


- Descri√ß√£o:
Cria um cursor para executar o comando SQL.
        cursor.execute("DELETE FROM produtos WHERE nome = ?", (nome_produto,))


- Descri√ß√£o:
Executa o comando SQL para deletar o registro:
- DELETE FROM produtos: Remove registros da tabela.
- WHERE nome = ?: Filtra os registros pelo nome.
- Usa uma tupla com um elemento (nome_produto,) para substituir o placeholder.
        conexao.commit()


- Descri√ß√£o:
Confirma a remo√ß√£o dos dados ao salvar as altera√ß√µes no banco de dados.
    except sqlite3.Error as e:
        print("Erro ao remover produto:", e)
        conexao.rollback()


- Descri√ß√£o:
Se ocorrer um erro:
- Imprime uma mensagem detalhando o erro.
- Reverte as altera√ß√µes com rollback().

Bloco Principal: Uso do CRUD
if __name__ == "__main__":


- Descri√ß√£o:
Verifica se o script est√° sendo executado como programa principal.
- Prop√≥sito:
Se for o caso, executa o bloco abaixo. Se o c√≥digo for importado como m√≥dulo em outro script, este bloco n√£o ser√° executado.
    db = "padaria.db"


- Descri√ß√£o:
Define uma vari√°vel db com o nome do arquivo do banco de dados.
    conexao = criar_conexao(db)


- Descri√ß√£o:
Chama a fun√ß√£o criar_conexao com o nome do banco.
- Resultado:
Se a conex√£o for bem-sucedida, o objeto de conex√£o √© armazenado em conexao.
    if conexao is not None:


- Descri√ß√£o:
Verifica se a conex√£o foi criada com sucesso (n√£o √© None).
        criar_tabela(conexao)


- Descri√ß√£o:
Chama a fun√ß√£o criar_tabela passando a conex√£o.
- Prop√≥sito:
Cria a tabela produtos no banco de dados (caso ela ainda n√£o exista).
Opera√ß√£o Create (Inserir Produto)
        produto = ("P√£o Franc√™s", 0.50, "2025-12-30")
        inserir_produto(conexao, produto)


- Descri√ß√£o:
- Define uma tupla produto com os dados do produto.
- Chama a fun√ß√£o inserir_produto para adicionar o produto √† tabela.
- Observa√ß√£o:
O produto inserido possui nome, pre√ßo e validade definidos conforme os padr√µes da tabela.
Opera√ß√£o Read (Consultar Produtos)
        produtos = consultar_produtos(conexao)
        print("Produtos no estoque:")
        for prod in produtos:
            print(prod)


- Descri√ß√£o:
- Chama a fun√ß√£o consultar_produtos para obter todos os registros da tabela produtos e armazena o resultado em produtos.
- Imprime uma mensagem header e, em seguida, itera sobre a lista de registros, imprimindo cada produto.
Opera√ß√£o Update (Atualizar Produto)
        atualizar_produto(conexao, 0.55, "P√£o Franc√™s")


- Descri√ß√£o:
Chama a fun√ß√£o atualizar_produto, alterando o pre√ßo do P√£o Franc√™s para 0.55.
Consulta Ap√≥s Update
        produtos = consultar_produtos(conexao)
        print("Produtos ap√≥s atualiza√ß√£o:")
        for prod in produtos:
            print(prod)


- Descri√ß√£o:
- Realiza uma nova consulta para verificar as altera√ß√µes.
- Imprime novamente os produtos, mostrando que o pre√ßo foi atualizado.
Opera√ß√£o Delete (Remover Produto)
        remover_produto(conexao, "P√£o Franc√™s")


- Descri√ß√£o:
Chama a fun√ß√£o remover_produto para excluir da tabela o produto cujo nome √© "P√£o Franc√™s".
Consulta Final Ap√≥s Dele√ß√£o
        produtos = consultar_produtos(conexao)
        print("Produtos ap√≥s remo√ß√£o:")
        for prod in produtos:
            print(prod)


- Descri√ß√£o:
- Consulta novamente o banco de dados para listar os produtos.
- Imprime os registros atuais, demonstrando que o produto removido n√£o aparece mais.
        conexao.close()


- Descri√ß√£o:
Fecha a conex√£o com o banco de dados, liberando os recursos utilizados.
    else:
        print("Erro! N√£o foi poss√≠vel criar a conex√£o com o banco de dados.")


- Descri√ß√£o:
Se a conex√£o n√£o for estabelecida (ou seja, conexao for None), imprime uma mensagem de erro informando que houve problema na cria√ß√£o da conex√£o.

Resumo Geral
Cada parte do c√≥digo cumpre um papel fundamental na constru√ß√£o de um sistema CRUD utilizando SQLite3 em Python:
- Importa√ß√£o e Conex√£o:
Configuram o ambiente para manipula√ß√£o do banco com sqlite3.connect().
- Cria√ß√£o do Cursor:
Permite executar comandos SQL e interagir com o banco.
- Execu√ß√£o dos Comandos SQL:
Comandos CREATE, INSERT, SELECT, UPDATE e DELETE s√£o executados por meio do m√©todo cursor.execute(), usando par√¢metros para seguran√ßa.
- Commit e Rollback:
As altera√ß√µes s√£o salvas com commit() e, em caso de erro, revertidas com rollback(), mantendo a integridade do banco.
- Fechamento da Conex√£o:
Importante para liberar recursos ap√≥s as opera√ß√µes.
Este c√≥digo serve como um excelente ponto de partida para entender como interagir com SQLite utilizando o m√≥dulo sqlite3 do Python e implementar as opera√ß√µes CRUD de forma robusta e segura. Se precisar de mais esclarecimentos, estou √† disposi√ß√£o para ajudar a aprofundar os conceitos!


‚úÖ 1. Conceito de Chaves Prim√°rias e Chaves Estrangeiras
üîπ Chave prim√°ria (Primary Key - PK) ‚Üí Identifica unicamente cada registro dentro de uma tabela.
üîπ Chave estrangeira (Foreign Key - FK) ‚Üí Conecta uma tabela com outra, garantindo refer√™ncia entre os dados.
üí° Exemplo de estrutura com FK:
CREATE TABLE pedidos (
    id INTEGER PRIMARY KEY,
    data TEXT,
    total REAL
);

CREATE TABLE itens_pedido (
    id INTEGER PRIMARY KEY,
    id_pedido INTEGER,
    id_produto INTEGER,
    quantidade INTEGER,
    FOREIGN KEY (id_pedido) REFERENCES pedidos(id),
    FOREIGN KEY (id_produto) REFERENCES produtos(id)
);


‚úÖ Aqui, garantimos que cada item do pedido est√° vinculado ao pedido correto e ao produto correspondente!

‚úÖ 2. Tipos de Relacionamento entre Tabelas
‚úî 1 para 1 ‚Üí Um registro em uma tabela corresponde a apenas um na outra.
‚úî 1 para muitos ‚Üí Um registro em uma tabela pode estar relacionado com v√°rios na outra.
‚úî Muitos para muitos ‚Üí Cria uma tabela intermedi√°ria para conectar registros entre duas tabelas.
üí° Exemplo de "muitos para muitos" com pedidos e produtos:
Cada pedido pode ter v√°rios produtos, e cada produto pode estar em v√°rios pedidos. Para isso, criamos a tabela intermedi√°ria itens_pedido, como mostrado acima.

‚úÖ 3. Integridade Referencial e ON DELETE / ON UPDATE
Para evitar problemas ao excluir ou modificar registros, usamos regras de a√ß√£o como:
üîπ CASCADE ‚Üí Se um pedido for deletado, os itens do pedido tamb√©m ser√£o.
üîπ SET NULL ‚Üí Se um produto for deletado, os pedidos que tinham ele ficam com NULL.
üîπ NO ACTION ‚Üí Bloqueia exclus√µes se houver refer√™ncias ativas.
üí° Exemplo de ON DELETE CASCADE:
CREATE TABLE itens_pedido (
    id INTEGER PRIMARY KEY,
    id_pedido INTEGER,
    id_produto INTEGER,
    FOREIGN KEY (id_pedido) REFERENCES pedidos(id) ON DELETE CASCADE,
    FOREIGN KEY (id_produto) REFERENCES produtos(id) ON DELETE CASCADE
);


üî• Isso garante que, ao excluir um pedido, todos os itens dele tamb√©m s√£o removidos automaticamente, sem precisar deletar manualmente!

‚úÖ 4. JOINs para Consulta de Dados Relacionados
‚úî INNER JOIN ‚Üí Retorna apenas os registros que t√™m correspond√™ncia entre tabelas.
‚úî LEFT JOIN ‚Üí Retorna todos os registros de uma tabela, mesmo que n√£o tenham correspond√™ncia na outra.
‚úî RIGHT JOIN (n√£o suportado no SQLite) ‚Üí Seria o oposto do LEFT JOIN.
üí° Exemplo de INNER JOIN para buscar produtos dentro de pedidos:
SELECT pedidos.id, pedidos.data, produtos.nome, itens_pedido.quantidade 
FROM pedidos
INNER JOIN itens_pedido ON pedidos.id = itens_pedido.id_pedido
INNER JOIN produtos ON itens_pedido.id_produto = produtos.id;


üî• Esse comando traz os pedidos e os produtos dentro deles!

‚úÖ 5. √çndices para Otimizar Consultas Relacionadas
‚úî Criar √≠ndices em chaves estrangeiras para melhorar a velocidade de busca.
‚úî Evitar consultas pesadas com LIKE '%', que podem gerar lentid√£o.
üí° Exemplo de cria√ß√£o de √≠ndice para buscas r√°pidas:
CREATE INDEX idx_pedido_produto ON itens_pedido (id_pedido, id_produto);


‚úÖ Agora, consultas que envolvem pedidos e produtos ser√£o muito mais r√°pidas!

üî• Conclus√£o:
Para garantir que o MVP da Padaria/Adega tenha um banco de dados organizado e funcional, voc√™ precisa estudar:
‚úÖ Chaves prim√°rias e estrangeiras
‚úÖ Tipos de relacionamento entre tabelas
‚úÖ Integridade referencial (ON DELETE / ON UPDATE)
‚úÖ JOINs para consultas eficientes
‚úÖ √çndices para otimizar velocidade

