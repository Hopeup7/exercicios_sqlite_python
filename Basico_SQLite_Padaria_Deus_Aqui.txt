
Guia Completo: CRUD com SQLite3 em Python

1. Introdução
O SQLite é um sistema de banco de dados SQL leve e auto-suficiente, que utiliza um único arquivo para armazenar todos os dados. Ele é considerado ideal para aplicações de pequeno e médio porte, pois dispensa a necessidade de um servidor dedicado. Em Python, a biblioteca nativa sqlite3 permite que você interaja com bancos SQLite de forma simples e direta.
Porque usar SQLite3?
- Leve e portátil: Basta um arquivo (.db) para armazenar e transportar os dados.
- Sem configuração complexa: Vem integrado com o Python, sem necessidade de instaladores adicionais.
- Fácil de operar: Ideal para protótipos, MVPs, aplicativos desktop e sistemas embarcados.
- Ideal para CRUD: Operações simples de Create, Read, Update e Delete podem ser implementadas rapidamente.

2. Configuração e Primeiros Passos com SQLite3
2.1 Importando a Biblioteca
import sqlite3


- O que faz?
Importa a biblioteca sqlite3 para que possamos utilizar suas funções e métodos para interagir com o SQLite dentro do Python.
- Por que é essencial?
Sem essa importação, você não terá acesso aos métodos que permitem:
- Conectar/ criar um banco de dados.
- Executar comandos SQL.
- Manipular os resultados de consultas.
2.2 Estabelecendo a Conexão com o Banco de Dados
conexao = sqlite3.connect("padaria.db")


- O que faz?
Cria uma conexão com o banco de dados chamado "padaria.db". Se esse arquivo não existir, ele será criado automaticamente.
- Boas práticas:
- Utilize nomes que identifiquem o projeto (ex.: "padaria.db") para facilitar a organização dos dados.
- Em projetos maiores, é comum isolar a lógica de conexão em uma função ou classe.
2.3 Criando um Cursor para Executar Comandos SQL
cursor = conexao.cursor()


- O que faz?
O cursor é um objeto que permite a execução de comandos SQL (como SELECT, INSERT, UPDATE e DELETE) e a iteração sobre os resultados.
- Importância:
Sem o cursor, você não terá acesso ao método de execução dos comandos e não conseguirá manipular os dados.
2.4 Executando Consultas e Obtendo Resultados
A. Executando uma Consulta
Antes de usar os métodos de busca (como fetchall() ou fetchone()), você deve executar uma consulta:
cursor.execute("SELECT * FROM produtos")


- Explicação:
Este comando executa uma consulta SQL que seleciona todos os registros da tabela produtos.
B. Obtendo os Resultados com fetchall()
resultado = cursor.fetchall()


- O que faz?
Este método retorna uma lista com todos os registros resultantes da consulta SQL executada anteriormente.
- Observação:
O método fetchall() só faz sentido depois de uma chamada a execute(). Sem a execução de uma consulta, ele não retornará nenhum dado.
2.5 Fechando a Conexão
conexao.close()


- O que faz?
Fecha a conexão com o banco de dados, liberando recursos e garantindo que as operações realizadas sejam finalizadas de forma segura.
- Boa prática:
Sempre feche a conexão assim que terminar suas operações para evitar vazamentos de memória e problemas de bloqueio do banco de dados.

3. Operações Básicas (CRUD) com SQLite3
As operações CRUD são os pilares para manipulação dos dados. Cada uma delas é realizada utilizando comandos SQL através do sqlite3.
3.1 Create (Inserir Dados)
Exemplo: Inserir um novo produto
cursor.execute(
    "INSERT INTO produtos (nome, preco, validade) VALUES (?, ?, ?)",
    ("Pão Francês", 0.50, "2025-12-30")
)
conexao.commit()  # Confirma a transação e salva as mudanças no banco


- Detalhes:
- Utilizamos parâmetros (?) para evitar problemas de injeção de SQL.
- O comando commit() é essencial para aplicar as mudanças.
3.2 Read (Consultar Dados)
Exemplo: Selecionar todos os registros da tabela
cursor.execute("SELECT * FROM produtos")
produtos = cursor.fetchall()

for produto in produtos:
    print(produto)


- Detalhes:
- fetchall() retorna uma lista de tuplas, onde cada tupla representa um registro.
- É possível filtrar dados utilizando cláusulas WHERE, ORDER BY, entre outras.
3.3 Update (Atualizar Dados)
Exemplo: Atualizar o preço de um produto
cursor.execute(
    "UPDATE produtos SET preco = ? WHERE nome = ?",
    (0.55, "Pão Francês")
)
conexao.commit()


- Detalhes:
- A cláusula WHERE garante que somente os registros desejados sejam atualizados.
- Sempre confirme a alteração com commit().
3.4 Delete (Excluir Dados)
Exemplo: Remover um produto
cursor.execute("DELETE FROM produtos WHERE nome = ?", ("Pão Francês",))
conexao.commit()


- Detalhes:
- Assim como o update, a cláusula WHERE é essencial para evitar a exclusão de todos os registros.
- Confirme sempre com commit().

4. Boas Práticas ao Trabalhar com SQLite3
4.1 Uso de Parâmetros nas Consultas
- Sempre utilize parâmetros (como ?) em comandos SQL para evitar injeção de SQL.
- Exemplo:
cursor.execute("SELECT * FROM produtos WHERE preco < ?", (5.00,))


4.2 Gerenciamento de Conexão
- Sempre feche a conexão após concluir as operações para liberar recursos:
conexao.close()
- Use o padrão "context manager" com a cláusula with para gerenciar automaticamente a abertura e o fechamento:
import sqlite3
with sqlite3.connect("padaria.db") as conexao:
    cursor = conexao.cursor()
    # operações SQL aqui
# A conexão será fechada automaticamente ao sair do bloco


4.3 Controle de Transações
- Utilize conexao.commit() após cada operação que altera o banco (INSERT, UPDATE, DELETE).
- Em casos de falha, usar conexao.rollback() pode ajudar a manter a integridade dos dados.
4.4 Estrutura Modular
- Separe a lógica de conexão, execução de comandos e fechamento em funções ou classes, facilitando a manutenção e expansão do código.
4.5 Tratamento de Erros
- Use blocos try...except para capturar exceções e tratar erros adequadamente:
try:
    conexao = sqlite3.connect("padaria.db")
    cursor = conexao.cursor()
    # Executar comandos
    conexao.commit()
except sqlite3.Error as e:
    print("Erro ao operar no banco:", e)
    conexao.rollback()
finally:
    if conexao:
        conexao.close()



5. Exemplo Completo de um CRUD
Abaixo, um exemplo que une todas as operações CRUD com boas práticas:
import sqlite3

def criar_conexao(db_file):
    try:
        conexao = sqlite3.connect(db_file)
        return conexao
    except sqlite3.Error as e:
        print(e)
    return None

def criar_tabela(conexao):
    try:
        cursor = conexao.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS produtos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nome TEXT NOT NULL,
                preco REAL NOT NULL,
                validade TEXT
            )
        """)
        conexao.commit()
    except sqlite3.Error as e:
        print("Erro ao criar tabela:", e)

def inserir_produto(conexao, produto):
    try:
        cursor = conexao.cursor()
        cursor.execute(
            "INSERT INTO produtos (nome, preco, validade) VALUES (?, ?, ?)",
            produto
        )
        conexao.commit()
        return cursor.lastrowid
    except sqlite3.Error as e:
        print("Erro ao inserir produto:", e)
        conexao.rollback()
        return None

def consultar_produtos(conexao):
    cursor = conexao.cursor()
    cursor.execute("SELECT * FROM produtos")
    return cursor.fetchall()

def atualizar_produto(conexao, novo_preco, nome_produto):
    try:
        cursor = conexao.cursor()
        cursor.execute("UPDATE produtos SET preco = ? WHERE nome = ?", (novo_preco, nome_produto))
        conexao.commit()
    except sqlite3.Error as e:
        print("Erro ao atualizar produto:", e)
        conexao.rollback()

def remover_produto(conexao, nome_produto):
    try:
        cursor = conexao.cursor()
        cursor.execute("DELETE FROM produtos WHERE nome = ?", (nome_produto,))
        conexao.commit()
    except sqlite3.Error as e:
        print("Erro ao remover produto:", e)
        conexao.rollback()

# Uso do CRUD
if __name__ == "__main__":
    db = "padaria.db"
    conexao = criar_conexao(db)
    if conexao is not None:
        criar_tabela(conexao)
        
        # Create
        produto = ("Pão Francês", 0.50, "2025-12-30")
        inserir_produto(conexao, produto)
        
        # Read
        produtos = consultar_produtos(conexao)
        print("Produtos no estoque:")
        for prod in produtos:
            print(prod)
        
        # Update
        atualizar_produto(conexao, 0.55, "Pão Francês")
        
        # Read novamente para confirmar alteração
        produtos = consultar_produtos(conexao)
        print("Produtos após atualização:")
        for prod in produtos:
            print(prod)
        
        # Delete
        remover_produto(conexao, "Pão Francês")
        
        # Final consulta
        produtos = consultar_produtos(conexao)
        print("Produtos após remoção:")
        for prod in produtos:
            print(prod)
        
        conexao.close()
    else:
        print("Erro! Não foi possível criar a conexão com o banco de dados.")



6. Conclusão
Principais pontos a serem lembrados:
- import sqlite3: É indispensável para acessar as funções do SQLite3 em Python.
- conexao = sqlite3.connect("padaria.db"): Garante a criação ou conexão com o banco de dados.
- cursor = conexao.cursor(): Permite executar comandos SQL.
- cursor.fetchall(): Retorna os resultados de uma consulta SQL (sempre após um execute()).
- conexao.close(): Fecha a conexão, preservando os recursos do sistema.
Adotando as boas práticas apresentadas, você estará preparado para transformar seus dados estruturados (como seu estoque da padaria) em um sistema robusto e escalável. Com essa base sólida, a integração com frameworks (como Flask) e outras tecnologias (como SQLite em produção) se torna natural e segura.



Ótima solicitação! Vamos analisar detalhadamente os comandos em inglês presentes nas operações CRUD do SQLite3, explicando o significado de cada palavra e por que algumas estão em maiúsculas. Também explicarei o conceito dos pontos de interrogação (?) nas consultas SQL. 🚀


1️⃣ Comandos SQL em Inglês e por que estão em Maiúsculas
CREATE TABLE
CREATE TABLE produtos (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    nome TEXT NOT NULL,
    preco REAL NOT NULL,
    validade TEXT
)


✅ Palavras em inglês e seus significados:
- CREATE → "Criar" → Define uma nova tabela no banco de dados.
- TABLE → "Tabela" → Especifica que um objeto do banco de dados a ser criado é uma tabela.
- PRIMARY KEY → "Chave Primária" → Identifica um registro de forma única.
- AUTOINCREMENT → "Autoincrementar" → Faz com que o valor da chave primária aumente automaticamente.
- TEXT → "Texto" → Tipo de dado que armazena caracteres.
- REAL → "Real" → Tipo de dado para números com casas decimais.
- NOT NULL → "Não pode ser nulo" → Garante que o campo deve ter um valor e não pode ficar vazio.
📌 Por que essas palavras estão em MAIÚSCULAS?
No SQL, comandos como CREATE TABLE e PRIMARY KEY são palavras reservadas, o que significa que fazem parte da sintaxe do SQL.
👉 Usar maiúsculas é uma convenção para diferenciar comandos SQL dos nomes das tabelas e colunas, melhorando a legibilidade do código.

INSERT INTO
INSERT INTO produtos (nome, preco, validade) VALUES (?, ?, ?)


✅ Palavras em inglês e seus significados:
- INSERT INTO → "Inserir dentro de" → Adiciona um novo registro a uma tabela.
- VALUES → "Valores" → Define os valores que serão inseridos nas colunas especificadas.
📌 Maiúsculas:
INSERT INTO é um comando SQL, então fica em maiúsculas por convenção, para deixar claro que é um comando e não um nome de tabela ou coluna.

SELECT
SELECT * FROM produtos


✅ Palavras em inglês e seus significados:
- SELECT → "Selecionar" → Retorna dados armazenados no banco de dados.
- FROM → "De" → Especifica a tabela de onde os dados serão extraídos.
- (*) → "Tudo" → O asterisco representa todos os campos de um registro, ou seja, solicita que sejam retornadas todas as colunas da tabela.
📌 Maiúsculas:
Assim como CREATE e INSERT, o SELECT é um comando SQL essencial, então está em maiúsculas para facilitar a leitura do código.

UPDATE
UPDATE produtos SET preco = ? WHERE nome = ?


✅ Palavras em inglês e seus significados:
- UPDATE → "Atualizar" → Modifica os dados de um registro existente.
- SET → "Definir" → Informa qual campo será alterado.
- WHERE → "Onde" → Especifica qual registro será atualizado (para evitar alterar todos os registros da tabela).
📌 Maiúsculas:
UPDATE, SET e WHERE são comandos SQL, então seguem a convenção de serem escritos em maiúsculas.

DELETE
DELETE FROM produtos WHERE nome = ?


✅ Palavras em inglês e seus significados:
- DELETE → "Excluir" → Remove um ou mais registros da tabela.
- FROM → "De" → Especifica de qual tabela os registros serão removidos.
- WHERE → "Onde" → Define qual registro específico será deletado.
📌 Maiúsculas:
DELETE, FROM e WHERE são comandos SQL, então seguem a convenção de legibilidade e destaque.

2️⃣ O conceito dos pontos de interrogação (?)
Nos comandos SQL, os pontos de interrogação (?) são utilizados para substituir valores dinamicamente dentro da consulta.
Por que usar ? ao invés de valores fixos?
✅ Evita injeção de SQL
Os ? atuam como placeholders, protegendo o banco contra ataques de SQL Injection, onde hackers podem inserir comandos maliciosos.
✅ Facilita a substituição de valores
Ao invés de definir valores fixos diretamente no SQL (INSERT INTO produtos VALUES ('Pão', 2.50, '2025-12-30')), podemos inserir os valores via Python, tornando o código mais flexível e seguro:
cursor.execute("INSERT INTO produtos (nome, preco, validade) VALUES (?, ?, ?)", ("Pão Francês", 0.50, "2025-12-30"))


- Os valores "Pão Francês", 0.50 e "2025-12-30" substituirão os ? automaticamente.
- Isso previne problemas de segurança e permite que o mesmo comando seja reutilizado para vários produtos.
Aplicação dos ? nos comandos CRUD
✅ INSERÇÃO de dados
cursor.execute("INSERT INTO produtos (nome, preco, validade) VALUES (?, ?, ?)", ("Pão Francês", 0.50, "2025-12-30"))


Os valores fornecidos em uma tupla substituem os ?, tornando a inserção dinâmica e segura.
✅ ATUALIZAÇÃO de dados
cursor.execute("UPDATE produtos SET preco = ? WHERE nome = ?", (0.55, "Pão Francês"))


O ? é substituído pelos valores 0.55 (preço atualizado) e "Pão Francês" (produto que será modificado).
✅ EXCLUSÃO de dados
cursor.execute("DELETE FROM produtos WHERE nome = ?", ("Pão Francês",))


O ? é substituído pelo nome do produto que será removido.
✅ CONSULTA de dados com filtro
cursor.execute("SELECT * FROM produtos WHERE preco < ?", (5.00,))


Aqui, o ? é substituído pelo preço máximo de 5.00, retornando produtos mais baratos que esse valor.
📌 Conclusão:
Os pontos de interrogação (?) tornam os comandos mais seguros, reutilizáveis e dinâmicos, permitindo que os valores sejam passados a partir de variáveis no Python. Isso é fundamental para um código mais profissional e protegido contra ataques.

Resumo Final
📝 Palavras em inglês:
Cada palavra nos comandos SQL tem um significado claro, e os termos estão em maiúsculas para seguir a convenção de legibilidade e diferenciação.
🔍 Maiúsculas:
- Comandos SQL como CREATE, SELECT, INSERT, UPDATE, DELETE sempre ficam em maiúsculas para melhorar a clareza do código.
- Nomes de tabelas e colunas não precisam estar em maiúsculas, pois são identificadores criados pelo usuário.
❓ Uso de ? nos comandos CRUD:
Os ? atuam como placeholders que garantem segurança, flexibilidade e proteção contra ataques de SQL Injection.
🚀 Conclusão Final:
Dominar esses conceitos é essencial para escrever código SQL eficiente e para um banco de dados seguro no seu projeto! Se quiser que eu aprofunde ainda mais alguma parte, me avise! 🔥💡

Linha 1: Importando a Biblioteca
import sqlite3


- Descrição:
Importa a biblioteca nativa do Python para interagir com bancos de dados SQLite.
- Por quê:
Sem essa importação, não teríamos acesso às funções e classes necessárias para criar conexões, executar comandos SQL e gerenciar a persistência dos dados.

Função: criar_conexao(db_file)
def criar_conexao(db_file):


- Descrição:
Define uma função chamada criar_conexao que recebe o nome do arquivo do banco de dados (db_file) como parâmetro.
- Propósito:
Criar e retornar uma conexão com o banco de dados especificado.
    try:


- Descrição:
Inicia um bloco try para capturar exceções que possam ocorrer durante o processo de conexão com o banco.
        conexao = sqlite3.connect(db_file)


- Descrição:
Tenta conectar ao banco de dados cujo nome foi passado em db_file.
- Comportamento:
Se o arquivo não existir, o SQLite criará um novo arquivo chamado "padaria.db" (ou outro nome fornecido).
        return conexao


- Descrição:
Se a conexão for bem-sucedida, retorna o objeto de conexão para ser usado em outras operações.
    except sqlite3.Error as e:
        print(e)


- Descrição:
Se ocorrer algum erro (do tipo sqlite3.Error), o bloco except captura o erro e imprime a mensagem de erro (e).
    return None


- Descrição:
Caso o bloco try falhe (ou mesmo após o bloco except), a função retorna None, sinalizando que a conexão não foi estabelecida.

Função: criar_tabela(conexao)
def criar_tabela(conexao):


- Descrição:
Define uma função chamada criar_tabela que recebe como parâmetro a conexão aberta com o banco de dados.
    try:


- Descrição:
Inicia um bloco de tentativa para criar a tabela, capturando quaisquer erros que possam ocorrer.
        cursor = conexao.cursor()


- Descrição:
Cria um cursor a partir da conexão.
- Propósito do Cursor:
Permite executar comandos SQL e manipular os resultados.
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS produtos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                nome TEXT NOT NULL,
                preco REAL NOT NULL,
                validade TEXT
            )
        """)


- Descrição:
Executa um comando SQL que cria uma tabela chamada produtos se ela ainda não existir.
- Detalhamento do Comando SQL:
- id INTEGER PRIMARY KEY AUTOINCREMENT: Cria uma coluna id que é chave primária e incrementa automaticamente.
- nome TEXT NOT NULL: Cria uma coluna nome do tipo texto, que não pode ser nula.
- preco REAL NOT NULL: Cria uma coluna preco para valores reais (números flutuantes) e obriga que haja um valor.
- validade TEXT: Cria uma coluna validade para armazenar a data de validade como texto (poderia ser usado um tipo de data, mas aqui optou-se por texto).
        conexao.commit()


- Descrição:
Confirma (faz o "commit") da transação, garantindo que a criação da tabela seja salva no banco de dados.
    except sqlite3.Error as e:
        print("Erro ao criar tabela:", e)


- Descrição:
Se houver qualquer erro ao executar o comando SQL ou durante a operação, o erro é capturado e uma mensagem de erro é exibida.

Função: inserir_produto(conexao, produto)
def inserir_produto(conexao, produto):


- Descrição:
Define uma função que insere um novo registro na tabela produtos.
- Parâmetros:
- conexao: objeto de conexão com o banco.
- produto: uma tupla contendo os valores (nome, preco, validade) do produto.
    try:


- Descrição:
Inicia um bloco try para tentar executar a inserção.
        cursor = conexao.cursor()


- Descrição:
Cria um cursor para executar o comando SQL.
        cursor.execute(
            "INSERT INTO produtos (nome, preco, validade) VALUES (?, ?, ?)",
            produto
        )


- Descrição:
Executa um comando SQL para inserir um novo produto.
- Detalhamento:
- O comando usa placeholders (?) para os valores, que serão substituídos pelo conteúdo da tupla produto.
- Essa abordagem é recomendada para evitar injeção de SQL.
        conexao.commit()


- Descrição:
Confirma a inserção dos dados no banco, salvando a transação.
        return cursor.lastrowid


- Descrição:
Retorna o ID (gerado automaticamente) do último registro inserido, o que pode ser útil para referência.
    except sqlite3.Error as e:
        print("Erro ao inserir produto:", e)
        conexao.rollback()
        return None


- Descrição:
Caso ocorra um erro:
- Imprime uma mensagem de erro.
- Executa rollback para desfazer qualquer alteração parcial na transação.
- Retorna None, indicando que a inserção falhou.

Função: consultar_produtos(conexao)
def consultar_produtos(conexao):


- Descrição:
Define uma função para consultar e retornar todos os registros da tabela produtos.
    cursor = conexao.cursor()


- Descrição:
Cria um cursor para executar comandos SQL.
    cursor.execute("SELECT * FROM produtos")


- Descrição:
Executa um comando SQL que seleciona todos os registros da tabela produtos.
    return cursor.fetchall()


- Descrição:
Retorna todos os resultados da consulta em forma de lista de tuplas, onde cada tupla representa um registro.

Função: atualizar_produto(conexao, novo_preco, nome_produto)
def atualizar_produto(conexao, novo_preco, nome_produto):


- Descrição:
Define uma função para atualizar o preço (preco) de um produto específico identificado pelo nome_produto.
    try:


- Descrição:
Inicia um bloco try para capturar possíveis erros durante a atualização.
        cursor = conexao.cursor()


- Descrição:
Cria um cursor para executar o comando SQL.
        cursor.execute("UPDATE produtos SET preco = ? WHERE nome = ?", (novo_preco, nome_produto))


- Descrição:
Executa o comando SQL para atualizar o preço:
- SET preco = ?: Define que o novo preço será igual ao valor passado em novo_preco.
- WHERE nome = ?: Indica que a alteração deve ocorrer apenas para o registro cujo nome corresponda a nome_produto.
- Os valores são passados como uma tupla (novo_preco, nome_produto).
        conexao.commit()


- Descrição:
Confirma a atualização no banco de dados, salvando as alterações.
    except sqlite3.Error as e:
        print("Erro ao atualizar produto:", e)
        conexao.rollback()


- Descrição:
Caso haja algum erro na atualização:
- O erro é impresso.
- A operação é revertida (rollback) para manter a integridade dos dados.

Função: remover_produto(conexao, nome_produto)
def remover_produto(conexao, nome_produto):


- Descrição:
Define uma função que remove um registro da tabela produtos com base no nome do produto.
    try:


- Descrição:
Inicia um bloco try para tentar executar a exclusão.
        cursor = conexao.cursor()


- Descrição:
Cria um cursor para executar o comando SQL.
        cursor.execute("DELETE FROM produtos WHERE nome = ?", (nome_produto,))


- Descrição:
Executa o comando SQL para deletar o registro:
- DELETE FROM produtos: Remove registros da tabela.
- WHERE nome = ?: Filtra os registros pelo nome.
- Usa uma tupla com um elemento (nome_produto,) para substituir o placeholder.
        conexao.commit()


- Descrição:
Confirma a remoção dos dados ao salvar as alterações no banco de dados.
    except sqlite3.Error as e:
        print("Erro ao remover produto:", e)
        conexao.rollback()


- Descrição:
Se ocorrer um erro:
- Imprime uma mensagem detalhando o erro.
- Reverte as alterações com rollback().

Bloco Principal: Uso do CRUD
if __name__ == "__main__":


- Descrição:
Verifica se o script está sendo executado como programa principal.
- Propósito:
Se for o caso, executa o bloco abaixo. Se o código for importado como módulo em outro script, este bloco não será executado.
    db = "padaria.db"


- Descrição:
Define uma variável db com o nome do arquivo do banco de dados.
    conexao = criar_conexao(db)


- Descrição:
Chama a função criar_conexao com o nome do banco.
- Resultado:
Se a conexão for bem-sucedida, o objeto de conexão é armazenado em conexao.
    if conexao is not None:


- Descrição:
Verifica se a conexão foi criada com sucesso (não é None).
        criar_tabela(conexao)


- Descrição:
Chama a função criar_tabela passando a conexão.
- Propósito:
Cria a tabela produtos no banco de dados (caso ela ainda não exista).
Operação Create (Inserir Produto)
        produto = ("Pão Francês", 0.50, "2025-12-30")
        inserir_produto(conexao, produto)


- Descrição:
- Define uma tupla produto com os dados do produto.
- Chama a função inserir_produto para adicionar o produto à tabela.
- Observação:
O produto inserido possui nome, preço e validade definidos conforme os padrões da tabela.
Operação Read (Consultar Produtos)
        produtos = consultar_produtos(conexao)
        print("Produtos no estoque:")
        for prod in produtos:
            print(prod)


- Descrição:
- Chama a função consultar_produtos para obter todos os registros da tabela produtos e armazena o resultado em produtos.
- Imprime uma mensagem header e, em seguida, itera sobre a lista de registros, imprimindo cada produto.
Operação Update (Atualizar Produto)
        atualizar_produto(conexao, 0.55, "Pão Francês")


- Descrição:
Chama a função atualizar_produto, alterando o preço do Pão Francês para 0.55.
Consulta Após Update
        produtos = consultar_produtos(conexao)
        print("Produtos após atualização:")
        for prod in produtos:
            print(prod)


- Descrição:
- Realiza uma nova consulta para verificar as alterações.
- Imprime novamente os produtos, mostrando que o preço foi atualizado.
Operação Delete (Remover Produto)
        remover_produto(conexao, "Pão Francês")


- Descrição:
Chama a função remover_produto para excluir da tabela o produto cujo nome é "Pão Francês".
Consulta Final Após Deleção
        produtos = consultar_produtos(conexao)
        print("Produtos após remoção:")
        for prod in produtos:
            print(prod)


- Descrição:
- Consulta novamente o banco de dados para listar os produtos.
- Imprime os registros atuais, demonstrando que o produto removido não aparece mais.
        conexao.close()


- Descrição:
Fecha a conexão com o banco de dados, liberando os recursos utilizados.
    else:
        print("Erro! Não foi possível criar a conexão com o banco de dados.")


- Descrição:
Se a conexão não for estabelecida (ou seja, conexao for None), imprime uma mensagem de erro informando que houve problema na criação da conexão.

Resumo Geral
Cada parte do código cumpre um papel fundamental na construção de um sistema CRUD utilizando SQLite3 em Python:
- Importação e Conexão:
Configuram o ambiente para manipulação do banco com sqlite3.connect().
- Criação do Cursor:
Permite executar comandos SQL e interagir com o banco.
- Execução dos Comandos SQL:
Comandos CREATE, INSERT, SELECT, UPDATE e DELETE são executados por meio do método cursor.execute(), usando parâmetros para segurança.
- Commit e Rollback:
As alterações são salvas com commit() e, em caso de erro, revertidas com rollback(), mantendo a integridade do banco.
- Fechamento da Conexão:
Importante para liberar recursos após as operações.
Este código serve como um excelente ponto de partida para entender como interagir com SQLite utilizando o módulo sqlite3 do Python e implementar as operações CRUD de forma robusta e segura. Se precisar de mais esclarecimentos, estou à disposição para ajudar a aprofundar os conceitos!


✅ 1. Conceito de Chaves Primárias e Chaves Estrangeiras
🔹 Chave primária (Primary Key - PK) → Identifica unicamente cada registro dentro de uma tabela.
🔹 Chave estrangeira (Foreign Key - FK) → Conecta uma tabela com outra, garantindo referência entre os dados.
💡 Exemplo de estrutura com FK:
CREATE TABLE pedidos (
    id INTEGER PRIMARY KEY,
    data TEXT,
    total REAL
);

CREATE TABLE itens_pedido (
    id INTEGER PRIMARY KEY,
    id_pedido INTEGER,
    id_produto INTEGER,
    quantidade INTEGER,
    FOREIGN KEY (id_pedido) REFERENCES pedidos(id),
    FOREIGN KEY (id_produto) REFERENCES produtos(id)
);


✅ Aqui, garantimos que cada item do pedido está vinculado ao pedido correto e ao produto correspondente!

✅ 2. Tipos de Relacionamento entre Tabelas
✔ 1 para 1 → Um registro em uma tabela corresponde a apenas um na outra.
✔ 1 para muitos → Um registro em uma tabela pode estar relacionado com vários na outra.
✔ Muitos para muitos → Cria uma tabela intermediária para conectar registros entre duas tabelas.
💡 Exemplo de "muitos para muitos" com pedidos e produtos:
Cada pedido pode ter vários produtos, e cada produto pode estar em vários pedidos. Para isso, criamos a tabela intermediária itens_pedido, como mostrado acima.

✅ 3. Integridade Referencial e ON DELETE / ON UPDATE
Para evitar problemas ao excluir ou modificar registros, usamos regras de ação como:
🔹 CASCADE → Se um pedido for deletado, os itens do pedido também serão.
🔹 SET NULL → Se um produto for deletado, os pedidos que tinham ele ficam com NULL.
🔹 NO ACTION → Bloqueia exclusões se houver referências ativas.
💡 Exemplo de ON DELETE CASCADE:
CREATE TABLE itens_pedido (
    id INTEGER PRIMARY KEY,
    id_pedido INTEGER,
    id_produto INTEGER,
    FOREIGN KEY (id_pedido) REFERENCES pedidos(id) ON DELETE CASCADE,
    FOREIGN KEY (id_produto) REFERENCES produtos(id) ON DELETE CASCADE
);


🔥 Isso garante que, ao excluir um pedido, todos os itens dele também são removidos automaticamente, sem precisar deletar manualmente!

✅ 4. JOINs para Consulta de Dados Relacionados
✔ INNER JOIN → Retorna apenas os registros que têm correspondência entre tabelas.
✔ LEFT JOIN → Retorna todos os registros de uma tabela, mesmo que não tenham correspondência na outra.
✔ RIGHT JOIN (não suportado no SQLite) → Seria o oposto do LEFT JOIN.
💡 Exemplo de INNER JOIN para buscar produtos dentro de pedidos:
SELECT pedidos.id, pedidos.data, produtos.nome, itens_pedido.quantidade 
FROM pedidos
INNER JOIN itens_pedido ON pedidos.id = itens_pedido.id_pedido
INNER JOIN produtos ON itens_pedido.id_produto = produtos.id;


🔥 Esse comando traz os pedidos e os produtos dentro deles!

✅ 5. Índices para Otimizar Consultas Relacionadas
✔ Criar índices em chaves estrangeiras para melhorar a velocidade de busca.
✔ Evitar consultas pesadas com LIKE '%', que podem gerar lentidão.
💡 Exemplo de criação de índice para buscas rápidas:
CREATE INDEX idx_pedido_produto ON itens_pedido (id_pedido, id_produto);


✅ Agora, consultas que envolvem pedidos e produtos serão muito mais rápidas!

🔥 Conclusão:
Para garantir que o MVP da Padaria/Adega tenha um banco de dados organizado e funcional, você precisa estudar:
✅ Chaves primárias e estrangeiras
✅ Tipos de relacionamento entre tabelas
✅ Integridade referencial (ON DELETE / ON UPDATE)
✅ JOINs para consultas eficientes
✅ Índices para otimizar velocidade

